local ink={}
ink.effect = love.graphics.newShader[[

// Inkblot Mandelbrot
// Autogenerated from Forth Haiku
// Generator by Stainless
// Haiku by anonymous

extern float time;
extern vec2 screen;

vec4 effect( vec4 color, Image tex, vec2 tc, vec2 pc )
	{
	float vars[32];
	float stack[8];
	vec2 position = ( pc.xy / screen.xy );
	vars[0] = time;    // t
	vars[0] =  cos(vars[0]);
	vars[1] = 1.0000000;
	vars[0] = vars[1] + vars[0];
	vars[1] = 2.0000000;
	vars[0] = vars[0] / vars[1];
	vars[1] = time;    // t
	vars[1] =  sin(vars[1]);
	vars[2] = 1.0000000;
	vars[1] = vars[2] + vars[1];
	vars[2] = 2.0000000;
	vars[1] = vars[1] / vars[2];
	vars[2] = position.y;    // y
	vars[3] = 0.7000000;
	vars[2] = vars[2] - vars[3];
	vars[3] = 3.0000000;
	vars[2] = vars[3] * vars[2];
	vars[3] = position.x;     // x
	vars[4] = 0.5000000;
	vars[3] = vars[3] - vars[4];
	vars[4] = 3.0000000;
	vars[3] = vars[4] * vars[3];
	stack[0] = vars[3];  // push
	stack[1] = vars[2];  // push
	vars[2] = vars[0];   // 2dup
	vars[3] = vars[1];   // 2dup
	vars[4] = (vars[0] * vars[2]) - (vars[1] * vars[3]);	// z*
	vars[1] = (vars[3] * vars[0]) + (vars[2] * vars[1]);	// z*
	vars[0] = vars[4];
	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[0] +=  vars[2];	// z+
	vars[1] +=  vars[3];	// z+

	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	stack[0] = vars[3];  // push
	stack[1] = vars[2];  // push
	vars[2] = vars[0];   // 2dup
	vars[3] = vars[1];   // 2dup
	vars[4] = (vars[0] * vars[2]) - (vars[1] * vars[3]);	// z*
	vars[1] = (vars[3] * vars[0]) + (vars[2] * vars[1]);	// z*
	vars[0] = vars[4];
	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[0] +=  vars[2];	// z+
	vars[1] +=  vars[3];	// z+

	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	stack[0] = vars[3];  // push
	stack[1] = vars[2];  // push
	vars[2] = vars[0];   // 2dup
	vars[3] = vars[1];   // 2dup
	vars[4] = (vars[0] * vars[2]) - (vars[1] * vars[3]);	// z*
	vars[1] = (vars[3] * vars[0]) + (vars[2] * vars[1]);	// z*
	vars[0] = vars[4];
	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[0] +=  vars[2];	// z+
	vars[1] +=  vars[3];	// z+

	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	stack[0] = vars[3];  // push
	stack[1] = vars[2];  // push
	vars[2] = vars[0];   // 2dup
	vars[3] = vars[1];   // 2dup
	vars[4] = (vars[0] * vars[2]) - (vars[1] * vars[3]);	// z*
	vars[1] = (vars[3] * vars[0]) + (vars[2] * vars[1]);	// z*
	vars[0] = vars[4];
	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[0] +=  vars[2];	// z+
	vars[1] +=  vars[3];	// z+

	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	stack[0] = vars[3];  // push
	stack[1] = vars[2];  // push
	vars[2] = vars[0];   // 2dup
	vars[3] = vars[1];   // 2dup
	vars[4] = (vars[0] * vars[2]) - (vars[1] * vars[3]);	// z*
	vars[1] = (vars[3] * vars[0]) + (vars[2] * vars[1]);	// z*
	vars[0] = vars[4];
	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[0] +=  vars[2];	// z+
	vars[1] +=  vars[3];	// z+

	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	stack[0] = vars[3];  // push
	stack[1] = vars[2];  // push
	vars[2] = vars[0];   // 2dup
	vars[3] = vars[1];   // 2dup
	vars[4] = (vars[0] * vars[2]) - (vars[1] * vars[3]);	// z*
	vars[1] = (vars[3] * vars[0]) + (vars[2] * vars[1]);	// z*
	vars[0] = vars[4];
	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[0] +=  vars[2];	// z+
	vars[1] +=  vars[3];	// z+

	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	stack[0] = vars[3];  // push
	stack[1] = vars[2];  // push
	vars[2] = vars[0];   // 2dup
	vars[3] = vars[1];   // 2dup
	vars[4] = (vars[0] * vars[2]) - (vars[1] * vars[3]);	// z*
	vars[1] = (vars[3] * vars[0]) + (vars[2] * vars[1]);	// z*
	vars[0] = vars[4];
	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[0] +=  vars[2];	// z+
	vars[1] +=  vars[3];	// z+

	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	stack[0] = vars[3];  // push
	stack[1] = vars[2];  // push
	vars[2] = vars[0];   // 2dup
	vars[3] = vars[1];   // 2dup
	vars[4] = (vars[0] * vars[2]) - (vars[1] * vars[3]);	// z*
	vars[1] = (vars[3] * vars[0]) + (vars[2] * vars[1]);	// z*
	vars[0] = vars[4];
	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[0] +=  vars[2];	// z+
	vars[1] +=  vars[3];	// z+

	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	stack[0] = vars[3];  // push
	stack[1] = vars[2];  // push
	vars[2] = vars[0];   // 2dup
	vars[3] = vars[1];   // 2dup
	vars[4] = (vars[0] * vars[2]) - (vars[1] * vars[3]);	// z*
	vars[1] = (vars[3] * vars[0]) + (vars[2] * vars[1]);	// z*
	vars[0] = vars[4];
	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[0] +=  vars[2];	// z+
	vars[1] +=  vars[3];	// z+

	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	stack[0] = vars[3];  // push
	stack[1] = vars[2];  // push
	vars[2] = vars[0];   // 2dup
	vars[3] = vars[1];   // 2dup
	vars[4] = (vars[0] * vars[2]) - (vars[1] * vars[3]);	// z*
	vars[1] = (vars[3] * vars[0]) + (vars[2] * vars[1]);	// z*
	vars[0] = vars[4];
	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[0] +=  vars[2];	// z+
	vars[1] +=  vars[3];	// z+

	vars[2] = stack[1];  // pop
	vars[3] = stack[0];  // pop

	vars[2] = vars[1];   // dup
	vars[1] = vars[2] * vars[1];
	vars[2] = vars[1];   // swap
	vars[1] = vars[0];   // swap
	vars[0] = vars[2];   // swap
	vars[2] = vars[1];   // dup
	vars[1] = vars[2] * vars[1];
	vars[0] = vars[1] + vars[0];
	vars[1] = vars[0];   // dup
	vars[2] = 1.0000000;
	if (vars[2] > vars[1])  vars[1] = 1.0;   // <
	else vars[1]=0.0;
	vars[0] = vars[1] * vars[0];
	vars[1] = time;    // t
	vars[1] =  sin(vars[1]);
	vars[2] = 1.0000000;
	vars[1] = vars[2] + vars[1];
	vars[2] = 2.0000000;
	vars[1] = vars[1] / vars[2];
	vars[2] = time;    // t
	vars[2] =  cos(vars[2]);
	vars[3] = 1.0000000;
	vars[2] = vars[3] + vars[2];
	vars[3] = 2.0000000;
	vars[2] = vars[2] / vars[3];
	vars[3] = position.y;    // y
	vars[4] = 0.7000000;
	vars[3] = vars[3] - vars[4];
	vars[4] = 3.0000000;
	vars[3] = vars[4] * vars[3];
	vars[4] = position.x;     // x
	vars[5] = 0.5000000;
	vars[4] = vars[4] - vars[5];
	vars[5] = 3.0000000;
	vars[4] = vars[5] * vars[4];
	stack[0] = vars[4];  // push
	stack[1] = vars[3];  // push
	vars[3] = vars[1];   // 2dup
	vars[4] = vars[2];   // 2dup
	vars[5] = (vars[1] * vars[3]) - (vars[2] * vars[4]);	// z*
	vars[2] = (vars[4] * vars[1]) + (vars[3] * vars[2]);	// z*
	vars[1] = vars[5];
	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	vars[5] = vars[3];   // 2dup
	vars[6] = vars[4];   // 2dup
	stack[0] = vars[6];  // push
	stack[1] = vars[5];  // push
	vars[1] +=  vars[3];	// z+
	vars[2] +=  vars[4];	// z+

	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	stack[0] = vars[4];  // push
	stack[1] = vars[3];  // push
	vars[3] = vars[1];   // 2dup
	vars[4] = vars[2];   // 2dup
	vars[5] = (vars[1] * vars[3]) - (vars[2] * vars[4]);	// z*
	vars[2] = (vars[4] * vars[1]) + (vars[3] * vars[2]);	// z*
	vars[1] = vars[5];
	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	vars[5] = vars[3];   // 2dup
	vars[6] = vars[4];   // 2dup
	stack[0] = vars[6];  // push
	stack[1] = vars[5];  // push
	vars[1] +=  vars[3];	// z+
	vars[2] +=  vars[4];	// z+

	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	stack[0] = vars[4];  // push
	stack[1] = vars[3];  // push
	vars[3] = vars[1];   // 2dup
	vars[4] = vars[2];   // 2dup
	vars[5] = (vars[1] * vars[3]) - (vars[2] * vars[4]);	// z*
	vars[2] = (vars[4] * vars[1]) + (vars[3] * vars[2]);	// z*
	vars[1] = vars[5];
	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	vars[5] = vars[3];   // 2dup
	vars[6] = vars[4];   // 2dup
	stack[0] = vars[6];  // push
	stack[1] = vars[5];  // push
	vars[1] +=  vars[3];	// z+
	vars[2] +=  vars[4];	// z+

	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	stack[0] = vars[4];  // push
	stack[1] = vars[3];  // push
	vars[3] = vars[1];   // 2dup
	vars[4] = vars[2];   // 2dup
	vars[5] = (vars[1] * vars[3]) - (vars[2] * vars[4]);	// z*
	vars[2] = (vars[4] * vars[1]) + (vars[3] * vars[2]);	// z*
	vars[1] = vars[5];
	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	vars[5] = vars[3];   // 2dup
	vars[6] = vars[4];   // 2dup
	stack[0] = vars[6];  // push
	stack[1] = vars[5];  // push
	vars[1] +=  vars[3];	// z+
	vars[2] +=  vars[4];	// z+

	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	stack[0] = vars[4];  // push
	stack[1] = vars[3];  // push
	vars[3] = vars[1];   // 2dup
	vars[4] = vars[2];   // 2dup
	vars[5] = (vars[1] * vars[3]) - (vars[2] * vars[4]);	// z*
	vars[2] = (vars[4] * vars[1]) + (vars[3] * vars[2]);	// z*
	vars[1] = vars[5];
	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	vars[5] = vars[3];   // 2dup
	vars[6] = vars[4];   // 2dup
	stack[0] = vars[6];  // push
	stack[1] = vars[5];  // push
	vars[1] +=  vars[3];	// z+
	vars[2] +=  vars[4];	// z+

	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	stack[0] = vars[4];  // push
	stack[1] = vars[3];  // push
	vars[3] = vars[1];   // 2dup
	vars[4] = vars[2];   // 2dup
	vars[5] = (vars[1] * vars[3]) - (vars[2] * vars[4]);	// z*
	vars[2] = (vars[4] * vars[1]) + (vars[3] * vars[2]);	// z*
	vars[1] = vars[5];
	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	vars[5] = vars[3];   // 2dup
	vars[6] = vars[4];   // 2dup
	stack[0] = vars[6];  // push
	stack[1] = vars[5];  // push
	vars[1] +=  vars[3];	// z+
	vars[2] +=  vars[4];	// z+

	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	stack[0] = vars[4];  // push
	stack[1] = vars[3];  // push
	vars[3] = vars[1];   // 2dup
	vars[4] = vars[2];   // 2dup
	vars[5] = (vars[1] * vars[3]) - (vars[2] * vars[4]);	// z*
	vars[2] = (vars[4] * vars[1]) + (vars[3] * vars[2]);	// z*
	vars[1] = vars[5];
	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	vars[5] = vars[3];   // 2dup
	vars[6] = vars[4];   // 2dup
	stack[0] = vars[6];  // push
	stack[1] = vars[5];  // push
	vars[1] +=  vars[3];	// z+
	vars[2] +=  vars[4];	// z+

	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	stack[0] = vars[4];  // push
	stack[1] = vars[3];  // push
	vars[3] = vars[1];   // 2dup
	vars[4] = vars[2];   // 2dup
	vars[5] = (vars[1] * vars[3]) - (vars[2] * vars[4]);	// z*
	vars[2] = (vars[4] * vars[1]) + (vars[3] * vars[2]);	// z*
	vars[1] = vars[5];
	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	vars[5] = vars[3];   // 2dup
	vars[6] = vars[4];   // 2dup
	stack[0] = vars[6];  // push
	stack[1] = vars[5];  // push
	vars[1] +=  vars[3];	// z+
	vars[2] +=  vars[4];	// z+

	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	stack[0] = vars[4];  // push
	stack[1] = vars[3];  // push
	vars[3] = vars[1];   // 2dup
	vars[4] = vars[2];   // 2dup
	vars[5] = (vars[1] * vars[3]) - (vars[2] * vars[4]);	// z*
	vars[2] = (vars[4] * vars[1]) + (vars[3] * vars[2]);	// z*
	vars[1] = vars[5];
	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	vars[5] = vars[3];   // 2dup
	vars[6] = vars[4];   // 2dup
	stack[0] = vars[6];  // push
	stack[1] = vars[5];  // push
	vars[1] +=  vars[3];	// z+
	vars[2] +=  vars[4];	// z+

	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	stack[0] = vars[4];  // push
	stack[1] = vars[3];  // push
	vars[3] = vars[1];   // 2dup
	vars[4] = vars[2];   // 2dup
	vars[5] = (vars[1] * vars[3]) - (vars[2] * vars[4]);	// z*
	vars[2] = (vars[4] * vars[1]) + (vars[3] * vars[2]);	// z*
	vars[1] = vars[5];
	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop
	vars[5] = vars[3];   // 2dup
	vars[6] = vars[4];   // 2dup
	stack[0] = vars[6];  // push
	stack[1] = vars[5];  // push
	vars[1] +=  vars[3];	// z+
	vars[2] +=  vars[4];	// z+

	vars[3] = stack[1];  // pop
	vars[4] = stack[0];  // pop


	vars[3] = vars[2];   // dup
	vars[2] = vars[3] * vars[2];
	vars[3] = vars[2];   // swap
	vars[2] = vars[1];   // swap
	vars[1] = vars[3];   // swap
	vars[3] = vars[2];   // dup
	vars[2] = vars[3] * vars[2];
	vars[1] = vars[2] + vars[1];
	vars[2] = vars[1];   // dup
	vars[3] = 1.0000000;
	if (vars[3] > vars[2])  vars[2] = 1.0;   // <
	else vars[2]=0.0;
	vars[1] = vars[2] * vars[1];
	vars[2] = time;    // t
	vars[2] =  cos(vars[2]);
	vars[3] = 1.0000000;
	vars[2] = vars[3] + vars[2];
	vars[3] = 2.0000000;
	vars[2] = vars[2] / vars[3];
	vars[3] = time;    // t
	vars[3] =  cos(vars[3]);
	vars[4] = 1.0000000;
	vars[3] = vars[4] + vars[3];
	vars[4] = 2.0000000;
	vars[3] = vars[3] / vars[4];
	vars[4] = position.y;    // y
	vars[5] = 0.7000000;
	vars[4] = vars[4] - vars[5];
	vars[5] = 3.0000000;
	vars[4] = vars[5] * vars[4];
	vars[5] = position.x;     // x
	vars[6] = 0.5000000;
	vars[5] = vars[5] - vars[6];
	vars[6] = 3.0000000;
	vars[5] = vars[6] * vars[5];
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	vars[6] = (vars[2] * vars[4]) - (vars[3] * vars[5]);	// z*
	vars[3] = (vars[5] * vars[2]) + (vars[4] * vars[3]);	// z*
	vars[2] = vars[6];
	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	vars[6] = vars[4];   // 2dup
	vars[7] = vars[5];   // 2dup
	stack[0] = vars[7];  // push
	stack[1] = vars[6];  // push
	vars[2] +=  vars[4];	// z+
	vars[3] +=  vars[5];	// z+

	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	vars[6] = (vars[2] * vars[4]) - (vars[3] * vars[5]);	// z*
	vars[3] = (vars[5] * vars[2]) + (vars[4] * vars[3]);	// z*
	vars[2] = vars[6];
	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	vars[6] = vars[4];   // 2dup
	vars[7] = vars[5];   // 2dup
	stack[0] = vars[7];  // push
	stack[1] = vars[6];  // push
	vars[2] +=  vars[4];	// z+
	vars[3] +=  vars[5];	// z+

	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	vars[6] = (vars[2] * vars[4]) - (vars[3] * vars[5]);	// z*
	vars[3] = (vars[5] * vars[2]) + (vars[4] * vars[3]);	// z*
	vars[2] = vars[6];
	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	vars[6] = vars[4];   // 2dup
	vars[7] = vars[5];   // 2dup
	stack[0] = vars[7];  // push
	stack[1] = vars[6];  // push
	vars[2] +=  vars[4];	// z+
	vars[3] +=  vars[5];	// z+

	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	vars[6] = (vars[2] * vars[4]) - (vars[3] * vars[5]);	// z*
	vars[3] = (vars[5] * vars[2]) + (vars[4] * vars[3]);	// z*
	vars[2] = vars[6];
	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	vars[6] = vars[4];   // 2dup
	vars[7] = vars[5];   // 2dup
	stack[0] = vars[7];  // push
	stack[1] = vars[6];  // push
	vars[2] +=  vars[4];	// z+
	vars[3] +=  vars[5];	// z+

	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	vars[6] = (vars[2] * vars[4]) - (vars[3] * vars[5]);	// z*
	vars[3] = (vars[5] * vars[2]) + (vars[4] * vars[3]);	// z*
	vars[2] = vars[6];
	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	vars[6] = vars[4];   // 2dup
	vars[7] = vars[5];   // 2dup
	stack[0] = vars[7];  // push
	stack[1] = vars[6];  // push
	vars[2] +=  vars[4];	// z+
	vars[3] +=  vars[5];	// z+

	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	vars[6] = (vars[2] * vars[4]) - (vars[3] * vars[5]);	// z*
	vars[3] = (vars[5] * vars[2]) + (vars[4] * vars[3]);	// z*
	vars[2] = vars[6];
	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	vars[6] = vars[4];   // 2dup
	vars[7] = vars[5];   // 2dup
	stack[0] = vars[7];  // push
	stack[1] = vars[6];  // push
	vars[2] +=  vars[4];	// z+
	vars[3] +=  vars[5];	// z+

	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	vars[6] = (vars[2] * vars[4]) - (vars[3] * vars[5]);	// z*
	vars[3] = (vars[5] * vars[2]) + (vars[4] * vars[3]);	// z*
	vars[2] = vars[6];
	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	vars[6] = vars[4];   // 2dup
	vars[7] = vars[5];   // 2dup
	stack[0] = vars[7];  // push
	stack[1] = vars[6];  // push
	vars[2] +=  vars[4];	// z+
	vars[3] +=  vars[5];	// z+

	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	vars[6] = (vars[2] * vars[4]) - (vars[3] * vars[5]);	// z*
	vars[3] = (vars[5] * vars[2]) + (vars[4] * vars[3]);	// z*
	vars[2] = vars[6];
	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	vars[6] = vars[4];   // 2dup
	vars[7] = vars[5];   // 2dup
	stack[0] = vars[7];  // push
	stack[1] = vars[6];  // push
	vars[2] +=  vars[4];	// z+
	vars[3] +=  vars[5];	// z+

	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	vars[6] = (vars[2] * vars[4]) - (vars[3] * vars[5]);	// z*
	vars[3] = (vars[5] * vars[2]) + (vars[4] * vars[3]);	// z*
	vars[2] = vars[6];
	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	vars[6] = vars[4];   // 2dup
	vars[7] = vars[5];   // 2dup
	stack[0] = vars[7];  // push
	stack[1] = vars[6];  // push
	vars[2] +=  vars[4];	// z+
	vars[3] +=  vars[5];	// z+

	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	stack[0] = vars[5];  // push
	stack[1] = vars[4];  // push
	vars[4] = vars[2];   // 2dup
	vars[5] = vars[3];   // 2dup
	vars[6] = (vars[2] * vars[4]) - (vars[3] * vars[5]);	// z*
	vars[3] = (vars[5] * vars[2]) + (vars[4] * vars[3]);	// z*
	vars[2] = vars[6];
	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop
	vars[6] = vars[4];   // 2dup
	vars[7] = vars[5];   // 2dup
	stack[0] = vars[7];  // push
	stack[1] = vars[6];  // push
	vars[2] +=  vars[4];	// z+
	vars[3] +=  vars[5];	// z+

	vars[4] = stack[1];  // pop
	vars[5] = stack[0];  // pop

	vars[4] = vars[3];   // dup
	vars[3] = vars[4] * vars[3];
	vars[4] = vars[3];   // swap
	vars[3] = vars[2];   // swap
	vars[2] = vars[4];   // swap
	vars[4] = vars[3];   // dup
	vars[3] = vars[4] * vars[3];
	vars[2] = vars[3] + vars[2];
	vars[3] = vars[2];   // dup
	vars[4] = 1.0000000;
	if (vars[4] > vars[3])  vars[3] = 1.0;   // <
	else vars[3]=0.0;
	vars[2] = vars[3] * vars[2];
	return vec4(vars[0],vars[1],vars[2],1.0);

	}
]]
return ink
